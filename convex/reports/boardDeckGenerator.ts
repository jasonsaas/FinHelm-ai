import { v } from "convex/values";
import { action, query, mutation } from "../_generated/server";
import { api } from "../_generated/api";
import { calculateFinancialRatios, getDateRange } from "../utils";

/**
 * Board Deck Generator
 * Auto-generates comprehensive board presentations with executive summaries,
 * key metrics vs targets, variance analysis, cash position, and strategic recommendations
 */

// Type definitions for board deck components
export interface BoardDeck {
  id: string;
  organizationId: string;
  generatedAt: number;
  period: {
    start: number;
    end: number;
    label: string;
  };
  executiveSummary: ExecutiveSummary;
  keyMetrics: KeyMetricsSection;
  varianceAnalysis: VarianceAnalysis;
  cashPositionForecast: CashPositionForecast;
  strategicRecommendations: StrategicRecommendations;
  slides: BoardSlide[];
  metadata: {
    version: string;
    template: string;
    autoGenerated: boolean;
    lastUpdated: number;
  };
}

export interface ExecutiveSummary {
  keyHighlights: string[];
  performanceOverview: {
    revenue: { current: number; target: number; variance: number; trend: 'up' | 'down' | 'flat' };
    profitability: { current: number; target: number; variance: number; trend: 'up' | 'down' | 'flat' };
    cashFlow: { current: number; target: number; variance: number; trend: 'up' | 'down' | 'flat' };
    growth: { current: number; target: number; variance: number; trend: 'up' | 'down' | 'flat' };
  };
  criticalIssues: Array<{
    issue: string;
    severity: 'high' | 'medium' | 'low';
    impact: string;
    recommendation: string;
  }>;
  outlook: {
    summary: string;
    confidence: number;
    riskFactors: string[];
    opportunities: string[];
  };
}

export interface KeyMetricsSection {
  financial: {
    revenue: MetricData;
    grossMargin: MetricData;
    operatingMargin: MetricData;
    netIncome: MetricData;
    cashFlow: MetricData;
    burnRate: MetricData;
  };
  operational: {
    customerAcquisition: MetricData;
    customerRetention: MetricData;
    averageRevenuePerUser: MetricData;
    lifetimeValue: MetricData;
    customerSatisfaction: MetricData;
  };
  liquidity: {
    cashPosition: MetricData;
    workingCapital: MetricData;
    currentRatio: MetricData;
    debtToEquity: MetricData;
  };
}

export interface MetricData {
  current: number;
  target: number;
  previousPeriod: number;
  variance: number;
  variancePercent: number;
  trend: 'up' | 'down' | 'flat';
  status: 'on-track' | 'at-risk' | 'off-track';
  commentary: string;
}

export interface VarianceAnalysis {
  revenueVariance: {
    totalVariance: number;
    rateVariance: number;
    volumeVariance: number;
    mixVariance: number;
    explanations: string[];
  };
  expenseVariance: {
    totalVariance: number;
    categoryBreakdown: Array<{
      category: string;
      budgeted: number;
      actual: number;
      variance: number;
      explanation: string;
    }>;
  };
  profitabilityVariance: {
    grossProfitVariance: number;
    operatingProfitVariance: number;
    netProfitVariance: number;
    keyDrivers: string[];
  };
}

export interface CashPositionForecast {
  currentPosition: number;
  projectedPositions: Array<{
    period: string;
    amount: number;
    confidence: number;
  }>;
  burnRate: {
    current: number;
    projected: number;
    runway: number;
  };
  scenarios: {
    conservative: { position: number; runway: number };
    optimistic: { position: number; runway: number };
    pessimistic: { position: number; runway: number };
  };
  fundingRecommendations: string[];
}

export interface StrategicRecommendations {
  immediate: Array<{
    priority: 'critical' | 'high' | 'medium';
    recommendation: string;
    rationale: string;
    expectedImpact: string;
    timeline: string;
    owner: string;
  }>;
  mediumTerm: Array<{
    priority: 'high' | 'medium' | 'low';
    recommendation: string;
    rationale: string;
    expectedImpact: string;
    timeline: string;
    resources: string;
  }>;
  strategic: Array<{
    initiative: string;
    objective: string;
    keyMetrics: string[];
    timeline: string;
    investment: number;
    expectedReturn: number;
  }>;
}

export interface BoardSlide {
  id: string;
  title: string;
  type: 'executive_summary' | 'metrics_dashboard' | 'variance_analysis' | 'cash_forecast' | 'recommendations' | 'appendix';
  content: any;
  notes: string[];
  order: number;
}

// Generate comprehensive board deck
export const generateBoardDeck = action({
  args: {
    organizationId: v.id("organizations"),
    period: v.optional(v.object({
      start: v.number(),
      end: v.number(),
      label: v.string(),
    })),
    template: v.optional(v.string()),
    includeAppendix: v.optional(v.boolean()),
    customSections: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    console.log(`Generating board deck for organization ${args.organizationId}`);
    
    // Default to current quarter if no period specified
    const period = args.period || {
      start: getDateRange("quarter", 0).start,
      end: getDateRange("quarter", 0).end,
      label: "Q3 2024"
    };
    
    // Get financial data
    const transactions = await ctx.runQuery(api.transactionActions.getTransactionsByOrg, {
      organizationId: args.organizationId,
      dateRange: { start: period.start, end: period.end },
    });
    
    const accounts = await ctx.runQuery(api.accountActions.getAccountHierarchy, {
      organizationId: args.organizationId,
    });
    
    // Get previous period data for comparisons
    const previousPeriod = getPreviousPeriod(period);
    const previousTransactions = await ctx.runQuery(api.transactionActions.getTransactionsByOrg, {
      organizationId: args.organizationId,
      dateRange: previousPeriod,
    });
    
    // Generate board deck sections
    const executiveSummary = await generateExecutiveSummary(
      transactions, 
      previousTransactions, 
      accounts
    );
    
    const keyMetrics = await generateKeyMetricsSection(
      transactions, 
      previousTransactions, 
      accounts
    );
    
    const varianceAnalysis = await generateVarianceAnalysis(
      transactions, 
      previousTransactions, 
      accounts
    );
    
    const cashPositionForecast = await generateCashPositionForecast(
      ctx,
      args.organizationId,
      transactions, 
      accounts
    );
    
    const strategicRecommendations = await generateStrategicRecommendations(
      executiveSummary,
      keyMetrics,
      varianceAnalysis,
      cashPositionForecast
    );
    
    // Create slides
    const slides = createBoardSlides(
      executiveSummary,
      keyMetrics,
      varianceAnalysis,
      cashPositionForecast,
      strategicRecommendations,
      args.includeAppendix || false
    );
    
    // Create board deck object
    const boardDeck: BoardDeck = {
      id: generateDeckId(),
      organizationId: args.organizationId,
      generatedAt: Date.now(),
      period,
      executiveSummary,
      keyMetrics,
      varianceAnalysis,
      cashPositionForecast,
      strategicRecommendations,
      slides,
      metadata: {
        version: "1.0",
        template: args.template || "standard",
        autoGenerated: true,
        lastUpdated: Date.now(),
      }
    };
    
    // Store the board deck
    const deckId = await ctx.runMutation(api.boardDeckGenerator.storeBoardDeck, {
      organizationId: args.organizationId,
      boardDeck: boardDeck,
    });
    
    console.log(`Board deck generated successfully: ${deckId}`);
    return {
      deckId,
      boardDeck,
      slideCount: slides.length,
      generatedAt: Date.now(),
    };
  },
});

// Generate executive summary
async function generateExecutiveSummary(
  transactions: any[],
  previousTransactions: any[],
  accounts: any[]
): Promise<ExecutiveSummary> {
  
  // Calculate current period metrics
  const currentRevenue = calculateRevenue(transactions, accounts);
  const currentProfitability = calculateProfitability(transactions, accounts);
  const currentCashFlow = calculateCashFlow(transactions, accounts);
  const currentGrowth = calculateGrowthRate(transactions, previousTransactions, accounts);
  
  // Mock targets (would come from budgets/plans in real implementation)
  const targets = {
    revenue: 3200000,
    profitability: 0.25, // 25% net margin
    cashFlow: 450000,
    growth: 0.15 // 15% growth rate
  };
  
  const keyHighlights = [
    `Revenue: $${formatCurrency(currentRevenue)} ${currentRevenue > targets.revenue ? '(ahead of target)' : '(below target)'}`,
    `Net Margin: ${(currentProfitability * 100).toFixed(1)}% ${currentProfitability > targets.profitability ? '(strong)' : '(needs improvement)'}`,
    `Cash Generation: $${formatCurrency(currentCashFlow)} monthly`,
    `Growth Rate: ${(currentGrowth * 100).toFixed(1)}% ${currentGrowth > targets.growth ? '(exceeding expectations)' : '(below plan)'}`
  ];
  
  const criticalIssues = [];
  
  // Identify critical issues
  if (currentRevenue < targets.revenue * 0.9) {
    criticalIssues.push({
      issue: "Revenue significantly below target",
      severity: "high" as const,
      impact: "Threatens achievement of annual targets",
      recommendation: "Implement accelerated sales initiatives and review pricing strategy"
    });
  }
  
  if (currentProfitability < targets.profitability * 0.8) {
    criticalIssues.push({
      issue: "Profitability below acceptable threshold",
      severity: "high" as const,
      impact: "Reduces cash generation and investor confidence",
      recommendation: "Conduct comprehensive cost review and optimization"
    });
  }
  
  if (currentCashFlow < 0) {
    criticalIssues.push({
      issue: "Negative cash flow generation",
      severity: "critical" as const,
      impact: "Threatens business continuity and requires immediate action",
      recommendation: "Implement emergency cash conservation measures"
    });
  }
  
  return {
    keyHighlights,
    performanceOverview: {
      revenue: {
        current: currentRevenue,
        target: targets.revenue,
        variance: currentRevenue - targets.revenue,
        trend: currentRevenue > targets.revenue * 1.05 ? 'up' : currentRevenue < targets.revenue * 0.95 ? 'down' : 'flat'
      },
      profitability: {
        current: currentProfitability,
        target: targets.profitability,
        variance: currentProfitability - targets.profitability,
        trend: currentProfitability > targets.profitability * 1.05 ? 'up' : currentProfitability < targets.profitability * 0.95 ? 'down' : 'flat'
      },
      cashFlow: {
        current: currentCashFlow,
        target: targets.cashFlow,
        variance: currentCashFlow - targets.cashFlow,
        trend: currentCashFlow > targets.cashFlow * 1.05 ? 'up' : currentCashFlow < targets.cashFlow * 0.95 ? 'down' : 'flat'
      },
      growth: {
        current: currentGrowth,
        target: targets.growth,
        variance: currentGrowth - targets.growth,
        trend: currentGrowth > targets.growth * 1.05 ? 'up' : currentGrowth < targets.growth * 0.95 ? 'down' : 'flat'
      }
    },
    criticalIssues,
    outlook: {
      summary: criticalIssues.length === 0 ? "Positive outlook with strong fundamentals" : 
               criticalIssues.some(i => i.severity === 'critical') ? "Challenging outlook requiring immediate action" :
               "Mixed outlook with areas for improvement",
      confidence: criticalIssues.length === 0 ? 0.85 : criticalIssues.some(i => i.severity === 'critical') ? 0.45 : 0.65,
      riskFactors: [
        "Economic uncertainty affecting customer demand",
        "Increased competition in core markets",
        "Supply chain disruptions impacting costs",
        "Talent acquisition challenges"
      ],
      opportunities: [
        "Expansion into new geographic markets",
        "Product innovation and differentiation",
        "Strategic partnerships and alliances",
        "Operational efficiency improvements"
      ]
    }
  };
}

// Generate key metrics section
async function generateKeyMetricsSection(
  transactions: any[],
  previousTransactions: any[],
  accounts: any[]
): Promise<KeyMetricsSection> {
  
  // Calculate current metrics
  const revenue = calculateRevenue(transactions, accounts);
  const grossMargin = calculateGrossMargin(transactions, accounts);
  const operatingMargin = calculateOperatingMargin(transactions, accounts);
  const netIncome = calculateNetIncome(transactions, accounts);
  const cashFlow = calculateCashFlow(transactions, accounts);
  const burnRate = calculateBurnRate(transactions);
  
  // Calculate previous period metrics
  const prevRevenue = calculateRevenue(previousTransactions, accounts);
  const prevGrossMargin = calculateGrossMargin(previousTransactions, accounts);
  const prevOperatingMargin = calculateOperatingMargin(previousTransactions, accounts);
  const prevNetIncome = calculateNetIncome(previousTransactions, accounts);
  const prevCashFlow = calculateCashFlow(previousTransactions, accounts);
  const prevBurnRate = calculateBurnRate(previousTransactions);
  
  // Mock targets (would come from budgets)
  const targets = {
    revenue: 3200000,
    grossMargin: 0.65,
    operatingMargin: 0.20,
    netIncome: 640000,
    cashFlow: 450000,
    burnRate: 380000,
    customerAcquisition: 250,
    customerRetention: 0.92,
    arpu: 12800,
    ltv: 128000,
    customerSatisfaction: 4.3,
    cashPosition: 6400000,
    workingCapital: 2100000,
    currentRatio: 2.2,
    debtToEquity: 0.35
  };
  
  const createMetricData = (current: number, target: number, previous: number, commentary: string): MetricData => {
    const variance = current - target;
    const variancePercent = target !== 0 ? (variance / target) * 100 : 0;
    const trend = current > previous * 1.02 ? 'up' : current < previous * 0.98 ? 'down' : 'flat';
    const status = Math.abs(variancePercent) <= 5 ? 'on-track' : 
                   Math.abs(variancePercent) <= 15 ? 'at-risk' : 'off-track';
    
    return {
      current,
      target,
      previousPeriod: previous,
      variance,
      variancePercent,
      trend,
      status,
      commentary
    };
  };
  
  return {
    financial: {
      revenue: createMetricData(revenue, targets.revenue, prevRevenue, "Revenue performance vs target and prior period"),
      grossMargin: createMetricData(grossMargin, targets.grossMargin, prevGrossMargin, "Gross margin efficiency and cost control"),
      operatingMargin: createMetricData(operatingMargin, targets.operatingMargin, prevOperatingMargin, "Operating leverage and expense management"),
      netIncome: createMetricData(netIncome, targets.netIncome, prevNetIncome, "Bottom line profitability"),
      cashFlow: createMetricData(cashFlow, targets.cashFlow, prevCashFlow, "Cash generation from operations"),
      burnRate: createMetricData(burnRate, targets.burnRate, prevBurnRate, "Monthly cash consumption rate")
    },
    operational: {
      customerAcquisition: createMetricData(275, targets.customerAcquisition, 230, "New customer acquisition rate"),
      customerRetention: createMetricData(0.89, targets.customerRetention, 0.91, "Customer retention and churn management"),
      averageRevenuePerUser: createMetricData(11200, targets.arpu, 10800, "Average revenue per user/account"),
      lifetimeValue: createMetricData(115000, targets.ltv, 108000, "Customer lifetime value calculation"),
      customerSatisfaction: createMetricData(4.1, targets.customerSatisfaction, 4.2, "Customer satisfaction score (NPS)")
    },
    liquidity: {
      cashPosition: createMetricData(5800000, targets.cashPosition, 6200000, "Total cash and cash equivalents"),
      workingCapital: createMetricData(1950000, targets.workingCapital, 2050000, "Working capital management"),
      currentRatio: createMetricData(2.0, targets.currentRatio, 2.1, "Short-term liquidity ratio"),
      debtToEquity: createMetricData(0.42, targets.debtToEquity, 0.38, "Capital structure and leverage")
    }
  };
}

// Generate variance analysis
async function generateVarianceAnalysis(
  transactions: any[],
  previousTransactions: any[],
  accounts: any[]
): Promise<VarianceAnalysis> {
  
  // Revenue variance analysis
  const currentRevenue = calculateRevenue(transactions, accounts);
  const budgetedRevenue = 3200000; // Mock budget
  const totalRevenueVariance = currentRevenue - budgetedRevenue;
  
  // Simplified variance decomposition (would be more sophisticated in real implementation)
  const revenueVariance = {
    totalVariance: totalRevenueVariance,
    rateVariance: totalRevenueVariance * 0.6, // 60% due to pricing
    volumeVariance: totalRevenueVariance * 0.3, // 30% due to volume
    mixVariance: totalRevenueVariance * 0.1, // 10% due to product mix
    explanations: [
      "Pricing pressure from competitive market conditions",
      "Lower than expected unit sales in Q3",
      "Shift in product mix toward lower-margin offerings",
      "New customer acquisition below forecast"
    ]
  };
  
  // Expense variance analysis
  const expenseCategories = [
    { category: "Sales & Marketing", budgeted: 800000, actual: 920000 },
    { category: "Research & Development", budgeted: 600000, actual: 580000 },
    { category: "General & Administrative", budgeted: 450000, actual: 465000 },
    { category: "Cost of Goods Sold", budgeted: 1120000, actual: 1200000 },
  ];
  
  const expenseVariance = {
    totalVariance: expenseCategories.reduce((sum, cat) => sum + (cat.actual - cat.budgeted), 0),
    categoryBreakdown: expenseCategories.map(cat => ({
      ...cat,
      variance: cat.actual - cat.budgeted,
      explanation: generateExpenseVarianceExplanation(cat.category, cat.actual, cat.budgeted)
    }))
  };
  
  // Profitability variance
  const profitabilityVariance = {
    grossProfitVariance: revenueVariance.totalVariance - (expenseCategories.find(c => c.category === "Cost of Goods Sold")?.variance || 0),
    operatingProfitVariance: revenueVariance.totalVariance - expenseVariance.totalVariance,
    netProfitVariance: revenueVariance.totalVariance - expenseVariance.totalVariance, // Simplified
    keyDrivers: [
      "Revenue shortfall primary driver of profit variance",
      "Increased COGS due to supply chain inflation",
      "Higher marketing spend to maintain market share",
      "R&D efficiency gains partially offset other variances"
    ]
  };
  
  return {
    revenueVariance,
    expenseVariance,
    profitabilityVariance
  };
}

// Generate cash position forecast
async function generateCashPositionForecast(
  ctx: any,
  organizationId: string,
  transactions: any[],
  accounts: any[]
): Promise<CashPositionForecast> {
  
  // Get current cash position
  const cashAccounts = accounts.filter(acc => acc.type === 'bank' || acc.type === 'cash');
  const currentPosition = cashAccounts.reduce((sum, acc) => sum + (acc.currentBalance || 0), 0);
  
  // Calculate current burn rate
  const burnRate = calculateBurnRate(transactions);
  
  // Generate projections (simplified - would use ML models in production)
  const projectedPositions = [];
  let position = currentPosition;
  
  for (let i = 1; i <= 12; i++) {
    position -= burnRate * (1 + (Math.random() * 0.1 - 0.05)); // Add some variance
    projectedPositions.push({
      period: `Month ${i}`,
      amount: Math.max(0, position),
      confidence: Math.max(0.5, 0.9 - (i * 0.03)) // Decreasing confidence over time
    });
  }
  
  // Calculate runway
  const runway = currentPosition > 0 ? currentPosition / burnRate : 0;
  
  // Generate scenarios
  const scenarios = {
    conservative: {
      position: currentPosition - (burnRate * 1.2 * 6), // 6 months with 20% higher burn
      runway: currentPosition / (burnRate * 1.2)
    },
    optimistic: {
      position: currentPosition - (burnRate * 0.8 * 6), // 6 months with 20% lower burn
      runway: currentPosition / (burnRate * 0.8)
    },
    pessimistic: {
      position: currentPosition - (burnRate * 1.5 * 6), // 6 months with 50% higher burn
      runway: currentPosition / (burnRate * 1.5)
    }
  };
  
  const fundingRecommendations = [];
  if (runway < 12) {
    fundingRecommendations.push("Consider raising capital within next 6 months");
  }
  if (runway < 6) {
    fundingRecommendations.push("Implement immediate cash conservation measures");
    fundingRecommendations.push("Explore emergency funding options");
  }
  
  return {
    currentPosition,
    projectedPositions,
    burnRate: {
      current: burnRate,
      projected: burnRate * 0.95, // Assume slight improvement
      runway
    },
    scenarios,
    fundingRecommendations
  };
}

// Generate strategic recommendations
async function generateStrategicRecommendations(
  executiveSummary: ExecutiveSummary,
  keyMetrics: KeyMetricsSection,
  varianceAnalysis: VarianceAnalysis,
  cashPositionForecast: CashPositionForecast
): Promise<StrategicRecommendations> {
  
  const immediate = [];
  const mediumTerm = [];
  const strategic = [];
  
  // Generate immediate recommendations based on critical issues
  executiveSummary.criticalIssues.forEach(issue => {
    if (issue.severity === 'critical' || issue.severity === 'high') {
      immediate.push({
        priority: issue.severity as 'critical' | 'high',
        recommendation: issue.recommendation,
        rationale: issue.issue,
        expectedImpact: issue.impact,
        timeline: "30-60 days",
        owner: "Executive Team"
      });
    }
  });
  
  // Add cash-related recommendations
  if (cashPositionForecast.burnRate.runway < 12) {
    immediate.push({
      priority: "high" as const,
      recommendation: "Implement comprehensive cash management program",
      rationale: "Cash runway below 12 months requires proactive management",
      expectedImpact: "Extend runway and improve financial stability",
      timeline: "Immediate",
      owner: "CFO"
    });
  }
  
  // Generate medium-term recommendations
  if (keyMetrics.operational.customerRetention.status === 'off-track') {
    mediumTerm.push({
      priority: "high" as const,
      recommendation: "Launch customer success initiative to improve retention",
      rationale: "Customer retention below target impacts long-term growth",
      expectedImpact: "5-10% improvement in retention rate",
      timeline: "3-6 months",
      resources: "Customer success team expansion, technology investment"
    });
  }
  
  if (varianceAnalysis.revenueVariance.totalVariance < 0) {
    mediumTerm.push({
      priority: "high" as const,
      recommendation: "Develop revenue acceleration program",
      rationale: "Revenue underperformance threatens annual targets",
      expectedImpact: "15-20% revenue uplift in remaining quarters",
      timeline: "2-4 months",
      resources: "Sales team expansion, marketing investment, pricing optimization"
    });
  }
  
  // Generate strategic initiatives
  strategic.push({
    initiative: "Digital Transformation Program",
    objective: "Modernize operations and improve customer experience",
    keyMetrics: ["Customer satisfaction score", "Operational efficiency", "Revenue per employee"],
    timeline: "12-18 months",
    investment: 2500000,
    expectedReturn: 7500000
  });
  
  strategic.push({
    initiative: "Market Expansion Initiative",
    objective: "Enter new geographic markets to diversify revenue",
    keyMetrics: ["New market revenue", "Customer acquisition", "Market share"],
    timeline: "6-12 months",
    investment: 1800000,
    expectedReturn: 5400000
  });
  
  return {
    immediate,
    mediumTerm,
    strategic
  };
}

// Create board slides from analysis sections
function createBoardSlides(
  executiveSummary: ExecutiveSummary,
  keyMetrics: KeyMetricsSection,
  varianceAnalysis: VarianceAnalysis,
  cashPositionForecast: CashPositionForecast,
  strategicRecommendations: StrategicRecommendations,
  includeAppendix: boolean
): BoardSlide[] {
  
  const slides: BoardSlide[] = [
    {
      id: "slide-1",
      title: "Executive Summary",
      type: "executive_summary",
      content: executiveSummary,
      notes: [
        "Review key highlights with focus on performance vs targets",
        "Address critical issues and their impact on business",
        "Discuss outlook and confidence level"
      ],
      order: 1
    },
    {
      id: "slide-2",
      title: "Key Performance Metrics",
      type: "metrics_dashboard",
      content: keyMetrics,
      notes: [
        "Walk through financial, operational, and liquidity metrics",
        "Highlight trends and status vs targets",
        "Explain variance drivers where significant"
      ],
      order: 2
    },
    {
      id: "slide-3",
      title: "Variance Analysis",
      type: "variance_analysis",
      content: varianceAnalysis,
      notes: [
        "Explain revenue variance components (rate, volume, mix)",
        "Review expense category variances",
        "Discuss profitability impact and key drivers"
      ],
      order: 3
    },
    {
      id: "slide-4",
      title: "Cash Position & Forecast",
      type: "cash_forecast",
      content: cashPositionForecast,
      notes: [
        "Present current cash position and runway",
        "Review projected cash flows and scenarios",
        "Discuss funding recommendations if applicable"
      ],
      order: 4
    },
    {
      id: "slide-5",
      title: "Strategic Recommendations",
      type: "recommendations",
      content: strategicRecommendations,
      notes: [
        "Present immediate action items with timelines",
        "Review medium-term initiatives",
        "Discuss strategic opportunities and investments"
      ],
      order: 5
    }
  ];
  
  if (includeAppendix) {
    slides.push({
      id: "slide-appendix",
      title: "Appendix - Detailed Analysis",
      type: "appendix",
      content: {
        detailedVariance: varianceAnalysis,
        sensitivityAnalysis: "Additional financial modeling and sensitivity analysis",
        marketAnalysis: "Competitive landscape and market conditions",
        riskAssessment: "Risk factors and mitigation strategies"
      },
      notes: [
        "Additional detail for questions and deeper dive",
        "Supporting analysis and data validation",
        "Risk assessment and scenario planning"
      ],
      order: 6
    });
  }
  
  return slides;
}

// Helper functions
function getPreviousPeriod(period: { start: number; end: number; label: string }) {
  const duration = period.end - period.start;
  return {
    start: period.start - duration,
    end: period.start,
    label: "Previous Period"
  };
}

function calculateRevenue(transactions: any[], accounts: any[]): number {
  const revenueAccounts = accounts.filter(acc => acc.type === 'income' || acc.type === 'revenue');
  return transactions
    .filter(txn => revenueAccounts.some(acc => acc._id === txn.accountId))
    .reduce((sum, txn) => sum + txn.amount, 0);
}

function calculateGrossMargin(transactions: any[], accounts: any[]): number {
  const revenue = calculateRevenue(transactions, accounts);
  const cogs = calculateCOGS(transactions, accounts);
  return revenue > 0 ? (revenue - cogs) / revenue : 0;
}

function calculateOperatingMargin(transactions: any[], accounts: any[]): number {
  const revenue = calculateRevenue(transactions, accounts);
  const operatingExpenses = calculateOperatingExpenses(transactions, accounts);
  const cogs = calculateCOGS(transactions, accounts);
  return revenue > 0 ? (revenue - cogs - operatingExpenses) / revenue : 0;
}

function calculateNetIncome(transactions: any[], accounts: any[]): number {
  const revenue = calculateRevenue(transactions, accounts);
  const totalExpenses = transactions
    .filter(txn => txn.type === 'expense')
    .reduce((sum, txn) => sum + txn.amount, 0);
  return revenue - totalExpenses;
}

function calculateCashFlow(transactions: any[], accounts: any[]): number {
  // Simplified operating cash flow calculation
  const revenue = calculateRevenue(transactions, accounts);
  const cashExpenses = transactions
    .filter(txn => txn.type === 'expense' && !txn.isNonCash)
    .reduce((sum, txn) => sum + txn.amount, 0);
  return revenue - cashExpenses;
}

function calculateBurnRate(transactions: any[]): number {
  const monthlyExpenses = transactions
    .filter(txn => txn.type === 'expense')
    .reduce((sum, txn) => sum + txn.amount, 0);
  return monthlyExpenses;
}

function calculateProfitability(transactions: any[], accounts: any[]): number {
  const netIncome = calculateNetIncome(transactions, accounts);
  const revenue = calculateRevenue(transactions, accounts);
  return revenue > 0 ? netIncome / revenue : 0;
}

function calculateGrowthRate(current: any[], previous: any[], accounts: any[]): number {
  const currentRevenue = calculateRevenue(current, accounts);
  const previousRevenue = calculateRevenue(previous, accounts);
  return previousRevenue > 0 ? (currentRevenue - previousRevenue) / previousRevenue : 0;
}

function calculateCOGS(transactions: any[], accounts: any[]): number {
  const cogsAccounts = accounts.filter(acc => 
    acc.type === 'cost_of_goods_sold' || acc.name.toLowerCase().includes('cogs')
  );
  return transactions
    .filter(txn => cogsAccounts.some(acc => acc._id === txn.accountId))
    .reduce((sum, txn) => sum + txn.amount, 0);
}

function calculateOperatingExpenses(transactions: any[], accounts: any[]): number {
  const opexAccounts = accounts.filter(acc => 
    acc.type === 'operating_expense' || 
    (acc.type === 'expense' && !acc.name.toLowerCase().includes('cogs'))
  );
  return transactions
    .filter(txn => opexAccounts.some(acc => acc._id === txn.accountId))
    .reduce((sum, txn) => sum + txn.amount, 0);
}

function generateExpenseVarianceExplanation(category: string, actual: number, budgeted: number): string {
  const variance = actual - budgeted;
  const isOver = variance > 0;
  
  switch (category) {
    case "Sales & Marketing":
      return isOver ? "Increased spending on customer acquisition campaigns" : "Marketing efficiency improvements";
    case "Research & Development":
      return isOver ? "Additional product development investments" : "Project timeline optimization";
    case "General & Administrative":
      return isOver ? "Higher professional services and compliance costs" : "Administrative efficiency gains";
    case "Cost of Goods Sold":
      return isOver ? "Supply chain inflation and material cost increases" : "Production efficiency improvements";
    default:
      return isOver ? "Higher than budgeted spending" : "Cost optimization achieved";
  }
}

function formatCurrency(amount: number): string {
  if (amount >= 1000000) {
    return `${(amount / 1000000).toFixed(1)}M`;
  } else if (amount >= 1000) {
    return `${(amount / 1000).toFixed(0)}K`;
  }
  return amount.toLocaleString();
}

function generateDeckId(): string {
  return `deck_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
}

// Mutation to store board deck
export const storeBoardDeck = mutation({
  args: {
    organizationId: v.id("organizations"),
    boardDeck: v.any(), // Would be properly typed in production
  },
  handler: async (ctx, args) => {
    // This would store in a board_decks table
    return `deck_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  },
});

// Query to get board decks
export const getBoardDecks = query({
  args: {
    organizationId: v.id("organizations"),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    // This would query the board_decks table
    return [];
  },
});