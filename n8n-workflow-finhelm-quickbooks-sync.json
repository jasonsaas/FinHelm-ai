{
  "meta": {
    "instanceId": "finhelm-quickbooks-sync"
  },
  "nodes": [
    {
      "id": "1",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [200, 300],
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        },
        "timezone": "America/New_York"
      }
    },
    {
      "id": "2",
      "name": "Initialize Variables",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 300],
      "parameters": {
        "functionCode": "// Initialize workflow variables and get last sync timestamp\nconst now = new Date();\nconst lastSyncKey = 'qb_last_sync_timestamp';\n\n// Try to get last sync time from static data, default to 24 hours ago if not found\nlet lastSync;\ntry {\n  const staticData = this.getWorkflowStaticData('global');\n  lastSync = staticData[lastSyncKey] || new Date(now - 24 * 60 * 60 * 1000).toISOString();\n} catch (error) {\n  console.log('Could not retrieve static data, using default lastSync');\n  lastSync = new Date(now - 24 * 60 * 60 * 1000).toISOString();\n}\n\nconsole.log(`Starting QuickBooks sync. Last sync: ${lastSync}`);\n\nreturn [{\n  json: {\n    lastSync: lastSync,\n    currentSync: now.toISOString(),\n    workflowId: 'qb_sync_production',\n    organizationId: 'org_default'\n  }\n}];"
      }
    },
    {
      "id": "3",
      "name": "Get QuickBooks Token",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [600, 300],
      "parameters": {
        "method": "GET",
        "url": "https://ardent-dog-632.convex.cloud/integrations/quickbooks/getActiveToken",
        "options": {
          "timeout": 10000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 1000
          }
        }
      }
    },
    {
      "id": "4",
      "name": "Validate Token Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [800, 300],
      "parameters": {
        "functionCode": "// Validate the token response and extract necessary data\nconst tokenData = items[0].json;\n\nif (!tokenData.accessToken) {\n  throw new Error('No access token received from Convex');\n}\n\nif (!tokenData.realmId) {\n  throw new Error('No realmId found in token response');\n}\n\n// Check if token is expired\nconst expiresAt = new Date(tokenData.expiresAt);\nconst now = new Date();\n\nif (expiresAt <= now) {\n  throw new Error('Access token has expired');\n}\n\nconsole.log(`Token validated successfully. RealmId: ${tokenData.realmId}`);\n\nreturn [{\n  json: {\n    ...items[1].json, // Preserve initial variables\n    accessToken: tokenData.accessToken,\n    realmId: tokenData.realmId,\n    tokenExpiresAt: tokenData.expiresAt\n  }\n}];"
      }
    },
    {
      "id": "5",
      "name": "Get Company Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1000, 100],
      "parameters": {
        "method": "GET",
        "url": "=https://sandbox-quickbooks.api.intuit.com/v3/company/{{$json.realmId}}/companyinfo/1",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "Authorization",
          "value": "=Bearer {{$json.accessToken}}"
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 2000
          }
        }
      }
    },
    {
      "id": "6",
      "name": "Query Invoices",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1000, 200],
      "parameters": {
        "method": "GET",
        "url": "=https://sandbox-quickbooks.api.intuit.com/v3/company/{{$json.realmId}}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "Authorization",
          "value": "=Bearer {{$json.accessToken}}"
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "=SELECT * FROM Invoice WHERE MetaData.LastUpdatedTime > '{{$json.lastSync}}'"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 2000
          }
        }
      }
    },
    {
      "id": "7",
      "name": "Query Payments",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1000, 300],
      "parameters": {
        "method": "GET",
        "url": "=https://sandbox-quickbooks.api.intuit.com/v3/company/{{$json.realmId}}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "Authorization",
          "value": "=Bearer {{$json.accessToken}}"
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "=SELECT * FROM Payment WHERE MetaData.LastUpdatedTime > '{{$json.lastSync}}'"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 2000
          }
        }
      }
    },
    {
      "id": "8",
      "name": "Query Expenses",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1000, 400],
      "parameters": {
        "method": "GET",
        "url": "=https://sandbox-quickbooks.api.intuit.com/v3/company/{{$json.realmId}}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "Authorization",
          "value": "=Bearer {{$json.accessToken}}"
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "=SELECT * FROM Purchase WHERE MetaData.LastUpdatedTime > '{{$json.lastSync}}'"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 2000
          }
        }
      }
    },
    {
      "id": "9",
      "name": "Get Accounts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1000, 500],
      "parameters": {
        "method": "GET",
        "url": "=https://sandbox-quickbooks.api.intuit.com/v3/company/{{$json.realmId}}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "Authorization",
          "value": "=Bearer {{$json.accessToken}}"
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "SELECT * FROM Account"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 2000
          }
        }
      }
    },
    {
      "id": "10",
      "name": "Merge API Responses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [1300, 300],
      "parameters": {
        "mode": "mergeByPosition",
        "options": {}
      }
    },
    {
      "id": "11",
      "name": "Transform Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1500, 300],
      "parameters": {
        "functionCode": "// Transform merged QuickBooks data into FinHelm webhook format\nconst currentSync = new Date().toISOString();\nlet totalRecords = 0;\n\n// Function to safely extract QB response data\nfunction extractQBData(response, fallback = []) {\n  try {\n    if (response && response.QueryResponse && response.QueryResponse.length > 0) {\n      const data = response.QueryResponse[0] || fallback;\n      return Array.isArray(data) ? data : [data];\n    }\n    return fallback;\n  } catch (error) {\n    console.log('Error extracting QB data:', error.message);\n    return fallback;\n  }\n}\n\n// Function to sanitize data and prevent injection\nfunction sanitizeData(obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  \n  const sanitized = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (typeof value === 'string') {\n      // Basic sanitization - remove HTML tags and control characters\n      sanitized[key] = value.replace(/<[^>]*>/g, '').replace(/[\\x00-\\x1F\\x7F]/g, '');\n    } else if (Array.isArray(value)) {\n      sanitized[key] = value.map(sanitizeData);\n    } else if (typeof value === 'object') {\n      sanitized[key] = sanitizeData(value);\n    } else {\n      sanitized[key] = value;\n    }\n  }\n  return sanitized;\n}\n\n// Extract data from each API response\nlet companyInfo = {};\nlet invoices = [];\nlet payments = [];\nlet expenses = [];\nlet accounts = [];\n\n// Process Company Info (items[0])\ntry {\n  if (items[0] && items[0].json && items[0].json.QueryResponse) {\n    companyInfo = items[0].json.QueryResponse.CompanyInfo?.[0] || {};\n  }\n} catch (error) {\n  console.log('Error processing company info:', error.message);\n}\n\n// Process Invoices (items[1])\ntry {\n  if (items[1] && items[1].json) {\n    invoices = extractQBData(items[1].json.QueryResponse?.Invoice);\n    totalRecords += invoices.length;\n  }\n} catch (error) {\n  console.log('Error processing invoices:', error.message);\n}\n\n// Process Payments (items[2])\ntry {\n  if (items[2] && items[2].json) {\n    payments = extractQBData(items[2].json.QueryResponse?.Payment);\n    totalRecords += payments.length;\n  }\n} catch (error) {\n  console.log('Error processing payments:', error.message);\n}\n\n// Process Expenses (items[3])\ntry {\n  if (items[3] && items[3].json) {\n    expenses = extractQBData(items[3].json.QueryResponse?.Purchase);\n    totalRecords += expenses.length;\n  }\n} catch (error) {\n  console.log('Error processing expenses:', error.message);\n}\n\n// Process Accounts (items[4])\ntry {\n  if (items[4] && items[4].json) {\n    accounts = extractQBData(items[4].json.QueryResponse?.Account);\n    totalRecords += accounts.length;\n  }\n} catch (error) {\n  console.log('Error processing accounts:', error.message);\n}\n\n// Build the FinHelm webhook payload\nconst webhookPayload = {\n  workflowId: 'qb_sync_production',\n  dataType: 'full_sync',\n  source: 'quickbooks',\n  organizationId: 'org_default',\n  data: {\n    companyInfo: sanitizeData(companyInfo),\n    invoices: invoices.map(sanitizeData),\n    payments: payments.map(sanitizeData),\n    expenses: expenses.map(sanitizeData),\n    accounts: accounts.map(sanitizeData)\n  },\n  metadata: {\n    syncTimestamp: currentSync,\n    recordCount: totalRecords,\n    lastSyncTime: items[0]?.json?.lastSync || null,\n    syncSource: 'n8n_workflow'\n  }\n};\n\nconsole.log(`Data transformation completed. Total records: ${totalRecords}`);\nconsole.log(`Invoices: ${invoices.length}, Payments: ${payments.length}, Expenses: ${expenses.length}, Accounts: ${accounts.length}`);\n\nreturn [{ json: webhookPayload }];"
      }
    },
    {
      "id": "12",
      "name": "Send to FinHelm Webhook",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1700, 300],
      "parameters": {
        "method": "POST",
        "url": "https://ardent-dog-632.convex.cloud/webhook/n8n",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "httpHeaderAuth": {
          "name": "Authorization",
          "value": "Bearer {{$env.FINHELM_WEBHOOK_TOKEN}}"
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={{ $json }}",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "waitBetween": 5000,
            "maxWaitBetween": 15000
          },
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      }
    },
    {
      "id": "13",
      "name": "Update Sync Timestamp",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1900, 300],
      "parameters": {
        "functionCode": "// Update the last sync timestamp in static data after successful webhook delivery\nconst response = items[0].json;\nconst currentSync = new Date().toISOString();\n\n// Check if webhook was successful\nif (response.statusCode && response.statusCode >= 200 && response.statusCode < 300) {\n  try {\n    const staticData = this.getWorkflowStaticData('global');\n    staticData.qb_last_sync_timestamp = currentSync;\n    \n    console.log(`Successfully updated last sync timestamp to: ${currentSync}`);\n    \n    return [{\n      json: {\n        status: 'success',\n        syncCompleted: currentSync,\n        webhookResponse: response.body,\n        recordCount: response.body?.metadata?.recordCount || 0\n      }\n    }];\n  } catch (error) {\n    console.error('Error updating static data:', error.message);\n    throw new Error(`Failed to update sync timestamp: ${error.message}`);\n  }\n} else {\n  throw new Error(`Webhook delivery failed with status: ${response.statusCode}`);\n}"
      }
    },
    {
      "id": "14",
      "name": "Send Success Notification",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2100, 300],
      "parameters": {
        "functionCode": "// Log success and optionally send notifications\nconst syncData = items[0].json;\nconst message = `âœ… QuickBooks sync completed successfully!\\n` +\n               `â€¢ Sync Time: ${syncData.syncCompleted}\\n` +\n               `â€¢ Records Processed: ${syncData.recordCount}\\n` +\n               `â€¢ Status: ${syncData.status}`;\n\nconsole.log(message);\n\n// TODO: Add Slack/Email notification here if needed\n// Example Slack webhook call:\n// await this.helpers.httpRequest({\n//   method: 'POST',\n//   url: 'YOUR_SLACK_WEBHOOK_URL',\n//   body: { text: message },\n//   json: true\n// });\n\nreturn [{\n  json: {\n    ...syncData,\n    notificationSent: false, // Change to true when implementing notifications\n    message: message\n  }\n}];"
      }
    },
    {
      "id": "15",
      "name": "Handle Webhook Errors",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1900, 500],
      "parameters": {
        "functionCode": "// Handle webhook delivery errors with retry logic\nconst error = items[0].json.error || 'Unknown webhook error';\nconst timestamp = new Date().toISOString();\nconst executionId = this.getExecutionId();\n\n// Log detailed error information\nconsole.error(`ðŸš¨ QuickBooks Sync Error at ${timestamp}:`);\nconsole.error(`Execution ID: ${executionId}`);\nconsole.error(`Error: ${error}`);\n\nconst errorDetails = {\n  error: error,\n  timestamp: timestamp,\n  executionId: executionId,\n  workflowId: 'qb_sync_production',\n  status: 'failed',\n  retryable: true\n};\n\n// TODO: Send error notification to Slack/Email\n// Example error notification:\n// const errorMessage = `ðŸš¨ QuickBooks Sync Failed\\n` +\n//                     `Time: ${timestamp}\\n` +\n//                     `Error: ${error}\\n` +\n//                     `Execution: ${executionId}`;\n\nreturn [{\n  json: errorDetails\n}];"
      }
    },
    {
      "id": "16",
      "name": "General Error Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 700],
      "parameters": {
        "functionCode": "// Handle general workflow errors\nconst error = items[0].json.error || 'Unknown error occurred';\nconst timestamp = new Date().toISOString();\nconst executionId = this.getExecutionId();\n\nconsole.error(`QuickBooks Sync General Error at ${timestamp}: ${error}`);\nconsole.error(`Execution ID: ${executionId}`);\n\n// You can extend this to send notifications to Slack/Email\nreturn [{\n  json: {\n    error: error,\n    timestamp: timestamp,\n    executionId: executionId,\n    workflowId: 'qb_sync_production',\n    status: 'failed'\n  }\n}];"
      }
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Initialize Variables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Variables": {
      "main": [
        [
          {
            "node": "Get QuickBooks Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get QuickBooks Token": {
      "main": [
        [
          {
            "node": "Validate Token Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Token Response": {
      "main": [
        [
          {
            "node": "Get Company Info",
            "type": "main",
            "index": 0
          },
          {
            "node": "Query Invoices",
            "type": "main",
            "index": 0
          },
          {
            "node": "Query Payments",
            "type": "main",
            "index": 0
          },
          {
            "node": "Query Expenses",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Accounts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Company Info": {
      "main": [
        [
          {
            "node": "Merge API Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Invoices": {
      "main": [
        [
          {
            "node": "Merge API Responses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Query Payments": {
      "main": [
        [
          {
            "node": "Merge API Responses",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Query Expenses": {
      "main": [
        [
          {
            "node": "Merge API Responses",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Get Accounts": {
      "main": [
        [
          {
            "node": "Merge API Responses",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge API Responses": {
      "main": [
        [
          {
            "node": "Transform Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform Data": {
      "main": [
        [
          {
            "node": "Send to FinHelm Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to FinHelm Webhook": {
      "main": [
        [
          {
            "node": "Update Sync Timestamp",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Webhook Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Sync Timestamp": {
      "main": [
        [
          {
            "node": "Send Success Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "id": "Error Handler"
    }
  },
  "staticData": {},
  "tags": [
    {
      "id": "quickbooks",
      "name": "QuickBooks"
    },
    {
      "id": "finhelm",
      "name": "FinHelm"
    },
    {
      "id": "sync",
      "name": "Data Sync"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2024-12-01T00:00:00.000Z",
  "versionId": "1"
}